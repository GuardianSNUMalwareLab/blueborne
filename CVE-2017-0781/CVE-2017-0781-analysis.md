## CVE-2017-0781

CVE-2017-0781은 RCE(Remote Code Execution) 취약점으로, BNEP 프로토콜 패킷을 처리하는 과정에서 발생한다.

---

BNEP connection state는 컨트롤 메세지를 보내는 도중에 비동기적으로 달라질 수 있다.

이 때 컨트롤 메세지 중 특정한 메세지 (e.g. SETUP_CONNECTION_REQUEST)이후에 오는 메세지는 반드시 state가 CONNECTED 일때 처리가 되어야 한다 (default state는 IDLE).

따라서, state가 IDLE이면, state가 CONNECTED로 변화된 이후에 메세지를 처리하기 위해 컨트롤 메세지의 일부를 저장해두는 방식을 사용한다.


```c
// bnep_main.c

case BNEP_FRAME_CONTROL:
  ctrl_type = *p;
  p = bnep_process_control_packet (p_bcb, p, &rem_len, FALSE);
  if (ctrl_type == BNEP_SETUP_CONNECTION_REQUEST_MSG &&
      p_bcb->con_state != BNEP_STATE_CONNECTED &&
      extension_present && p && rem_len)
  {
      p_bcb->p_pending_data = (BT_HDR *)osi_malloc(rem_len);
      memcpy((UINT8 *)(p_bcb->p_pending_data + 1), p, rem_len);
      p_bcb->p_pending_data->len    = rem_len;
      p_bcb->p_pending_data->offset = 0;
  }
```

위의 코드는 BNEP 컨트롤 메세지를 처리하는 과정의 코드다.

위의 코드에서, 처리되지 않은 메세지를 저장하는 영역이 p_pending_data 인데, `memcpy()` 과정에서 실수가 발생하였다.

malloc()으로 p_pending_data에 할당되는 크기는 rem_len인데, memcpy()는 p_pending_data+1 인덱스부터 rem_len 사이즈를 할당하여 heap overflow가 발생한다.

이때 p_pending_data의 타입인 BT_HDR은 8byte 크기다. 즉 매번 allocation이 일어날 때마다 8byte의 heap overflow가 발생한다.

또한 이렇게 할당된 영역은 이후에 `free()` 되지 않는다.

---

위의 취약점을 이용하면 프로그램의 흐름(Instruction Pointer)을 조정할 수 있고, ROP 체인 기법을 이용하여 RCE(Remote Code Execution) 공격이 가능해진다.
