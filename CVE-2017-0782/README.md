## CVE-2017-0782

CVE-2017-0782는 CVE-2017-0781과 같이 RCE(Remote Code Execution) 취약점으로, bnep_data_ind 하의 flow 중에 발생한다.

---
bnep_process_control_packet 함수는 BNEP control message를 처리할 때 extension header를 통해 parent control message에 함께 붙어있는 sub-message를 파싱한다. 

이 때, BNEP에서는 수신자가 인식되지 않은 extension을 무시하는 것을 허락한다. 아래의 default case에서 extension header에 들어있는 extension length를 이용하여 인식되지 않은 control message를 skip하도록 시도한다.


```c
// bnep_process_control_packet.c

if ( is_ext )
{
  ext_len = *p++;
  *rem_len = *rem_len - 1 ;
}
...
control_type = *p++;
*rem_len = *rem_len - 1 ;
...
switch ( control_type )
{
...
default :
...
if ( is_ext )
{
  p += ( ext_len - 1 );
  *rem_len -= ( ext_len - 1 );
}
break ;
}
...
```

위의 함수에서 rem_len(parsing되지 않고 남은 bytes)은 16-bit unsigned short, ext_len은 8-bit unsigned로 정의되어 있다. 이 두 값은 모두 attacker가 control 가능한 값이다.(attacker-controlled packet안에 있으므로)

따라서, ext_len을 적당한 값으로 조정하여 rem_len을 0xff00보다 큰 값이 되도록 underflow 시킬 수 있다.

이후에 bnep_data_ind가 호출될 때 비정상적으로 커진 rem_len을 이용한다.


```c
...
while ( extension_present && p && rem_len )
{
  ext_type = * p ;
  extension_present = ext_type >> 7 ;
  ext_type &= 0x7F ;
/* if unknown extension present stop processing */
  if ( ext_type )
  {
    ...
    break ;
  }
  p++;
  rem_len--;
  p = bnep_process_control_packet ( p_bcb , p , & rem_len , TRUE );
}
p_buf -> offset += p_buf -> len - rem_len ;
p_buf -> len = rem_len ;
...
else if ( bnep_cb . p_data_ind_cb )
{
  (*bnep_cb . p_data_ind_cb )( p_bcb -> handle , p_src_addr , p_dst_addr ,
  protocol , p , rem_len , fw_ext_present );
  osi_free ( p_buf );
}
```

rem_len은 p_buf(actual packet structure)의 len으로 세팅된다. 따라서, p_buf는 매우 큰 len을 갖는다. 또한, p_buf의 offset이 len에 비해 매우 작아짐을 알 수 있다.

따라서, packet에 충분히 큰 payload를 실을 수 있다.

이후, bta_pan_data_buf_ind_cback 함수에서 p_buf는 memcpy에 의해 heap 영역에 복사된다.

```c
static void bta_pan_data_buf_ind_cback (
  uint16_t handle , const RawAddress & src , const RawAddress & dst ,
  uint16_t protocol , BT_HDR * p_buf , bool ext , bool forward )
{
...
  BT_HDR * p_new_buf ;
  if ( sizeof ( tBTA_PAN_DATA_PARAMS ) > p_buf -> offset ) {
  /* offset smaller than data structure in front of actual data */
    p_new_buf = ( BT_HDR *) osi_malloc ( PAN_BUF_SIZE );
    memcpy (( uint8_t *)( p_new_buf + 1 ) + sizeof ( tBTA_PAN_DATA_PARAMS ),
    ( uint8_t *)( p_buf + 1 ) + p_buf -> offset , p_buf -> len );
    ...
    osi_free ( p_buf );
    ...
```

이렇게 heap에 올라온 payload는 힙 오버플로우를 발생시키게 된다.

---

위의 취약점을 이용하면 프로그램의 흐름(Instruction Pointer)을 조정할 수 있고, ROP 체인 기법을 이용하여 RCE(Remote Code Execution) 공격이 가능해진다.
